/**
 * Recreate presidents collection in V2 PocketBase with same fields as V1
 * 
 * Usage:
 *   POCKETBASE_URL=http://127.0.0.1:8091 \
 *   V1_POCKETBASE_URL=http://127.0.0.1:8090 \
 *   POCKETBASE_ADMIN_EMAIL=admin@vma.agency \
 *   POCKETBASE_ADMIN_PASSWORD=password \
 *   npx tsx server/src/scripts/recreatePresidentsCollection.ts
 */

import PocketBase from 'pocketbase';

const v2PbUrl = process.env.POCKETBASE_URL || 'http://127.0.0.1:8091';
const v1PbUrl = process.env.V1_POCKETBASE_URL || 'http://127.0.0.1:8090';
const adminEmail = process.env.POCKETBASE_ADMIN_EMAIL;
const adminPassword = process.env.POCKETBASE_ADMIN_PASSWORD;

const v2Pb = new PocketBase(v2PbUrl);
const v1Pb = new PocketBase(v1PbUrl);

async function main() {
  console.log('üîÑ Recreating Presidents Collection in V2');
  console.log('==========================================');
  console.log(`V1 URL: ${v1PbUrl}`);
  console.log(`V2 URL: ${v2PbUrl}`);
  console.log('');

  if (!adminEmail || !adminPassword) {
    console.error('‚ùå POCKETBASE_ADMIN_EMAIL and POCKETBASE_ADMIN_PASSWORD must be set');
    process.exit(1);
  }

  try {
    // Authenticate with V2
    await v2Pb.admins.authWithPassword(adminEmail, adminPassword);
    console.log('‚úÖ Authenticated with V2 PocketBase');

    // Authenticate with V1 (may need same or different credentials)
    try {
      await v1Pb.admins.authWithPassword(adminEmail, adminPassword);
      console.log('‚úÖ Authenticated with V1 PocketBase');
    } catch (v1AuthError: any) {
      console.log('‚ö†Ô∏è  V1 authentication failed, trying public access...');
      // Continue - may be publicly readable
    }

    // Fetch presidents collection schema from V1
    console.log('');
    console.log('üì§ Fetching presidents collection schema from V1...');
    let v1Collection;
    try {
      v1Collection = await v1Pb.collections.getOne('presidents');
    } catch (err: any) {
      if (err?.status === 401) {
        console.error('‚ùå V1 requires admin authentication');
        console.error('   Try authenticating with V1 admin credentials');
        process.exit(1);
      }
      throw err;
    }
    console.log(`‚úÖ Found presidents collection in V1`);
    
    // Debug: log collection structure
    const collectionObj = v1Collection as any;
    console.log('   Collection keys:', Object.keys(collectionObj));
    const schema = collectionObj.fields || collectionObj.schema || [];
    console.log(`   Schema fields: ${schema.length}`);
    if (schema.length > 0) {
      console.log('   First field:', JSON.stringify(schema[0], null, 2));
    }

    // Check if collection exists in V2 - delete it first to ensure clean recreation
    console.log('');
    console.log('üîç Checking V2 collection...');
    try {
      const v2Collection = await v2Pb.collections.getOne('presidents');
      console.log('‚ö†Ô∏è  Presidents collection already exists in V2');
      console.log('   Deleting to recreate with all fields...');
      await v2Pb.collections.delete(v2Collection.id);
      console.log('‚úÖ Deleted existing collection');
    } catch (err: any) {
      if (err?.status === 404) {
        console.log('‚ÑπÔ∏è  Presidents collection doesn\'t exist in V2');
        console.log('   Will create new collection...');
      } else {
        throw err;
      }
    }

    // Filter out system fields (id, created, updated are auto-generated by PocketBase)
    const nonSystemFields = schema.filter((field: any) => {
      const isSystem = field.system || field.name === 'id' || field.name === 'created' || field.name === 'updated';
      return !isSystem;
    });
    console.log(`   Preparing ${nonSystemFields.length} non-system fields for V2...`);
    
    // Log field names
    console.log('   Field names:', nonSystemFields.map((f: any) => f.name).join(', '));

    // Prepare collection data
    const preparedFields = nonSystemFields.map((field: any) => {
      // Remove system-generated IDs, keep field structure
      const { id, system, ...fieldData } = field;
      return fieldData;
    });
    
    console.log(`   Prepared ${preparedFields.length} fields for API`);

    const collectionData: any = {
      name: 'presidents',
      type: 'base',
      schema: preparedFields,
      listRule: (v1Collection as any).listRule || '',
      viewRule: (v1Collection as any).viewRule || '',
      createRule: (v1Collection as any).createRule,
      updateRule: (v1Collection as any).updateRule,
      deleteRule: (v1Collection as any).deleteRule,
    };

    // Create collection
    console.log('');
    console.log('üìù Creating collection with all fields...');
    try {
      const created = await v2Pb.collections.create(collectionData);
      console.log('‚úÖ Created presidents collection');
      console.log('   Created collection ID:', (created as any).id);
      console.log('   Response fields count:', ((created as any).fields || (created as any).schema || []).length);
    } catch (createError: any) {
      console.error('‚ùå Error creating collection:', createError?.message);
      if (createError?.response) {
        console.error('Response:', JSON.stringify(createError.response, null, 2));
      }
      throw createError;
    }

    // Show field count
    const finalCollection = await v2Pb.collections.getOne('presidents');
    const finalFields = (finalCollection as any).fields || (finalCollection as any).schema || [];
    console.log('');
    console.log('‚úÖ Collection ready!');
    console.log(`   Fields: ${finalFields.length}`);
    console.log(`   List Rule: ${(finalCollection as any).listRule || '(empty = public)'}`);
    console.log(`   View Rule: ${(finalCollection as any).viewRule || '(empty = public)'}`);

    console.log('');
    console.log('üìã Field List:');
    finalFields.forEach((field: any, idx: number) => {
      const required = field.required ? '‚úÖ' : '  ';
      const unique = field.unique ? 'üîë' : '  ';
      console.log(`   ${idx + 1}. ${required} ${unique} ${field.name} (${field.type})`);
    });

    console.log('');
    console.log('‚úÖ Done! Collection is ready for data import.');
    console.log('   Admin UI: http://127.0.0.1:8091/_/');
  } catch (error: any) {
    console.error('');
    console.error('‚ùå Error:', error?.message || error);
    if (error?.response) {
      console.error('Response:', JSON.stringify(error.response, null, 2));
    }
    process.exit(1);
  }
}

main().catch(console.error);
